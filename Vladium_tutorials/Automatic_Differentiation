# Automatic Differentiation
# Reference: http://vladium.com/tutorials/study_julia_with_me/multiple_dispatch/

# Differentiate This
function myerf(x ::Number)
  âˆ‘ = 0.0
  xÂ² = x * x
  for k in 0 : 20 # hardcoding the number of summation terms for simplicity
      âˆ‘ += x / (factorial(k) * (2k + 1))
      x *= -xÂ²
  end
  return 2.0 / âˆšÏ€ * âˆ‘
end

# My sum-of-the-series implementation seems correct2:
using SpecialFunctions

myerf(0.7), erf(0.7)


# Baby Julia steps: operators, functions, and methods
g(x) = x * (x + x)

g_tree = :(x * (x + x)) # ':(...)' is the "quoting" operator here: it parses what's inside into a syntax tree

typeof(g_tree)
dump(g_tree)

# Julia operators are functions
x = 2
x + x # Operator form
+(x,x) # function form

# Julia functions are â€œoverloadableâ€ (or is it â€œoverridableâ€? ğŸ˜„)
x * x
"x" * "x"

 methods(*)

struct MyNum <:Number
    v ::Float64
end

 MyNum(2.0) * MyNum(2.0)

using Base
Base.:(*)(lhs ::MyNum, rhs ::MyNum) = MyNum(lhs.v * rhs.v)

MyNum(2.0) * MyNum(2.0)

methods(MyNum)

methods(*)

# binary ops:
Base.:(+)(lhs ::MyNum, rhs ::MyNum) = MyNum(lhs.v + rhs.v)
Base.:(-)(lhs ::MyNum, rhs ::MyNum) = MyNum(lhs.v - rhs.v)
Base.:(*)(lhs ::MyNum, rhs ::MyNum) = MyNum(lhs.v * rhs.v)
Base.:(\)(lhs ::MyNum, rhs ::MyNum) = MyNum(lhs.v / rhs.v)
